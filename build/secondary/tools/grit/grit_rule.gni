# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Instantiate grit. This will produce a script target to run grit, and a
# static library that compiles the .cc files.
#
# Parameters
#
#   source
#       Path to .grd file.
#
#   outputs (optional)
#       List of outputs from grit, relative to the target_gen_dir. If supplied,
#       a call to Grit to compute the outputs can be skipped which will make
#       GN run faster. Grit will verify at build time that this list is correct
#       and will fail if there is a mismatch between the outputs specified by
#       the .grd file and the outputs list here.
#
#       To get this list, you can look in the .grd file for
#       <output filename="..." and put those filename here. The base directory
#       of the list in Grit and the output list specified in the GN grit target
#       are the same (the target_gen_dir) so you can generally copy the names
#       exactly.
#
#       To get the list of outputs programatically, run:
#           python tools/grit/grit_info.py --outputs . path/to/your.grd
#       And strip the leading "./" from the output files.
#
#   grit_flags (optional)
#       List of strings containing extra command-line flags to pass to Grit.
#
#   resource_ids (optional)
#     Path to a grit "firstidsfile". Default is
#     //tools/gritsettings/resource_ids. Set to "" to use the value specified in
#     the <grit> nodes of the processed files.
#
#   output_dir (optional)
#     Directory for generated files.
#
#   deps  (optional)
#   visibility  (optional)
#       Normal meaning.
#
# Example
#
#   grit("my_resources") {
#     source = "myfile.grd"  # source is required.
#     grit_flags = [ "-E", "foo=bar" ]  # Optional extra flags.
#     # You can also put deps here if the grit source depends on generated
#     # files.
#   }
import ("//build/config/crypto.gni")
import ("//build/config/features.gni")
import ("//build/config/ui.gni")

grit_defines = []

# Mac and iOS want Title Case strings.
use_titlecase_in_grd_files = is_mac || is_ios
if (use_titlecase_in_grd_files) {
  grit_defines += [ "-D", "use_titlecase" ]
}

if (is_chrome_branded) {
  grit_defines += [
    "-D", "_google_chrome",
    "-E", "CHROMIUM_BUILD=google_chrome",
  ]
} else {
  grit_defines += [
    "-D", "_chromium",
    "-E", "CHROMIUM_BUILD=chromium",
  ]
}

if (is_chromeos) {
  grit_defines += [
    "-D", "chromeos",
    "-D", "scale_factors=2x"
  ]
}

if (is_desktop_linux) {
  grit_defines += [ "-D", "desktop_linux" ]
}

if (toolkit_views) {
  grit_defines += [ "-D", "toolkit_views" ]
}

if (use_aura) {
  grit_defines += [ "-D", "use_aura" ]
}

if (use_ash) {
  grit_defines += [ "-D", "use_ash" ]
}

if (use_nss_certs) {
  grit_defines += [ "-D", "use_nss" ]
}

if (use_ozone) {
  grit_defines += [ "-D", "use_ozone" ]
}

if (enable_image_loader_extension) {
  grit_defines += [ "-D", "image_loader_extension" ]
}

if (enable_remoting) {
  grit_defines += [ "-D", "remoting" ]
}

if (is_android) {
  grit_defines += [
    "-t", "android",
    "-E", "ANDROID_JAVA_TAGGED_ONLY=true",
  ]
}

if (is_mac || is_ios) {
  grit_defines += [ "-D", "scale_factors=2x" ]
}

if (is_ios) {
  grit_defines += [
    "-t", "ios",
    # iOS uses a whitelist to filter resources.
    "-w", rebase_path("//build/ios/grit_whitelist.txt", root_build_dir),
  ]
}

if (enable_extensions) {
  grit_defines += [ "-D", "enable_extensions" ]
}
if (enable_plugins) {
  grit_defines += [ "-D", "enable_plugins" ]
}
if (printing_mode != 0) {
  grit_defines += [ "-D", "enable_printing" ]
  if (printing_mode == 1) {
    grit_defines += [ "-D", "enable_full_printing" ]
  }
}
if (enable_themes) {
  grit_defines += [ "-D", "enable_themes" ]
}
if (enable_app_list) {
  grit_defines += [ "-D", "enable_app_list" ]
}
if (enable_settings_app) {
  grit_defines += [ "-D", "enable_settings_app" ]
}
if (enable_google_now) {
  grit_defines += [ "-D", "enable_google_now" ]
}
# Note: use_concatenated_impulse_responses is omitted. It is never used and
# should probably be removed from GYP build.
if (enable_webrtc) {
  grit_defines += [ "-D", "enable_webrtc" ]
}
# Note: enable_hangout_services_extension is omitted. It is never set in the
# GYP build. Need to figure out what it's for.
if (enable_task_manager) {
  grit_defines += [ "-D", "enable_task_manager" ]
}
if (enable_notifications) {
  grit_defines += [ "-D", "enable_notifications" ]
}
if (enable_wifi_bootstrapping) {
  grit_defines += [ "-D", "enable_wifi_bootstrapping" ]
}
if (enable_service_discovery) {
  grit_defines += [ "-D", "enable_service_discovery" ]
}

grit_resource_id_file = "//tools/gritsettings/resource_ids"
grit_info_script = "//tools/grit/grit_info.py"

template("grit") {
  assert(defined(invoker.source),
         "\"source\" must be defined for the grit template $target_name")

  if (defined(invoker.resource_ids)) {
    resource_ids = invoker.resource_ids
  } else {
    resource_ids = grit_resource_id_file
  }

  if (defined(invoker.output_dir)) {
    output_dir = invoker.output_dir
  } else {
    output_dir = target_gen_dir
  }

  # These are all passed as arguments to the script so have to be relative to
  # the build directory.
  if (resource_ids != "") {
    resource_ids = rebase_path(resource_ids, root_build_dir)
  }
  rebased_output_dir = rebase_path(output_dir, root_build_dir)
  source_path = rebase_path(invoker.source, root_build_dir)

  if (defined(invoker.grit_flags)) {
    grit_flags = invoker.grit_flags
  } else {
    grit_flags = []  # These are optional so default to empty list.
  }

  grit_inputs = [ invoker.source ]

  assert_files_flags = []
  if (defined(invoker.outputs)) {
    # If the declaration specified outputs, we want to make sure that they
    # actually match what Grit is writing. We write the list to a file (some
    # of the output lists are long enough to not fit on a Windows command line)
    # and ask Grit to verify those are the actual outputs at runtime.
    asserted_list_file = "$target_out_dir/${target_name}_expected_outputs.txt"
    write_file(asserted_list_file,
               rebase_path(invoker.outputs, root_build_dir, target_gen_dir))
    assert_files_flags += [
      "--assert-file-list=" + rebase_path(asserted_list_file, root_build_dir),
    ]
    grit_outputs = get_path_info(
        rebase_path(invoker.outputs, ".", target_gen_dir),
        "abspath")
  } else {
    # Ask Grit for the output list.
    grit_outputs_build_rel = exec_script(grit_info_script,
      [ "--outputs", "$rebased_output_dir", source_path, "-f", resource_ids ] +
      grit_flags,
      "list lines")

    # The names returned by grit are relative to the current (build) directory,
    # but references to files in this template are expected to be relative to
    # the invoking BUILD.gn file's directory. Make it absolute so there's no
    # ambiguity.
    grit_outputs = get_path_info(
        rebase_path(grit_outputs_build_rel, ".", root_build_dir), "abspath")
  }

  # The config and the action below get this visibility son only the generated
  # source set can depend on them. The variable "target_name" will get
  # overwritten inside the innter classes so we need to compute it here.
  target_visibility = ":$target_name"

  # The current grit setup makes an file in $output_dir/grit/foo.h that
  # the source code expects to include via "grit/foo.h". It would be nice to
  # change this to including absolute paths relative to the root gen directory
  # (like "mycomponent/foo.h"). This config sets up the include path.
  grit_config = target_name + "_grit_config"
  config(grit_config) {
    include_dirs = [ output_dir ]
    visibility = target_visibility
  }

  grit_custom_target = target_name + "_grit"
  action(grit_custom_target) {
    script = "//tools/grit/grit.py"
    inputs = grit_inputs
    outputs = grit_outputs
    depfile = "$target_out_dir/${target_name}.d"

    args = [
      "-i", source_path, "build",
      "-f", resource_ids,
      "-o", rebased_output_dir,
      "--depdir", ".",
      "--depfile", rebase_path(depfile, root_build_dir),
    ] + grit_defines + grit_flags + assert_files_flags

    visibility = target_visibility

    deps = [ "//tools/grit:grit_sources" ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  # This is the thing that people actually link with, it must be named the
  # same as the argument the template was invoked with.
  source_set(target_name) {
    # Since we generate a file, we need to be run before the targets that
    # depend on us.
    sources = grit_outputs

    # Deps set on the template invocation will go on the grit script running
    # target rather than this library.
    deps = [ ":$grit_custom_target" ]
    direct_dependent_configs = [ ":$grit_config" ]

    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    if (defined(invoker.output_name)) {
      output_name = invoker.output_name
    }
  }
}
